/**
 * @file push/push.ts
 * Relution SDK
 *
 * Created by Thomas Beckmann on 06.07.2016
 * Copyright 2016 M-Way Solutions GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
var _ = require('lodash');
var diag = require('../core/diag');
var device = require('../core/device');
var domain = require('../core/domain');
var init = require('../core/init');
var server = require('../security/server');
var web = require('../web');
/**
 * endpoint URL of push REST API set up by CLI project generation by default.
 *
 * @type {string}
 */
var pushUrl = 'api/v1/push';
;
/**
 * registers a target device with the current Relution server.
 *
 * The implementation relies on backend code generated by CLI. That code attempts fetching an
 * existing device using the metadata information send as request body data. If it finds one, that
 * device is updated. Otherwise a new device is created and stored in the database. The updated
 * device registration record then is sent as response body data.
 *
 * @param registrationId to register.
 * @return promise of registered device.
 *
 * @internal SDK client code must call configurePushDevice() which obtains the token.
 */
function registerPushDevice(registrationId, options) {
    if (options === void 0) { options = {}; }
    var user = server.getCurrentAuthorization().name;
    var pushInitOptions = init.initOptions.push;
    return device.ready.then(function (info) {
        var providerType;
        switch (info.platform.id) {
            case 'android':
                providerType = 'GCM';
                break;
            case 'ios':
                // when a senderID is configured,
                // iOS device is registered at APNS which generates a token registered in turn at GCM,
                // so that pushes are send using GCM to either type of device.
                providerType = pushInitOptions.ios.senderID ? 'GCM' : 'APNS';
                break;
            case 'windowsphone':
                providerType = 'WNS';
                break;
            case 'blackberry':
                providerType = 'PAP';
                break;
            default:
                providerType = 'MCAP';
                break;
        }
        diag.debug.assert(!!info.device, 'The current implementation supports mobile devices only!');
        return {
            uuid: null,
            providerType: providerType,
            token: registrationId,
            user: user,
            deviceIdentifier: info.uuid,
            vendor: info.device.manufacturer,
            name: info.device.name,
            osVersion: info.device.version,
            model: info.device.model,
            type: info.device.name,
            appPackageName: info.device.appIdentifier,
            appVersion: info.device.appVersionCode || info.device.appVersionName,
            attributes: options.attributes,
            tags: options.tags,
            badge: options.badge
        };
    }).then(function (device) {
        diag.debug.assert(device.providerType !== 'PAP', 'Relution Server does not yet support this!');
        diag.debug.assert(device.providerType !== 'MCAP', 'Relution SDK does not yet implement this!');
        return web.post(pushUrl + '/registration', device);
    });
}
exports.registerPushDevice = registerPushDevice;
/**
 * posts push notification(s).
 *
 * Usually the server sends push notifications on its own behalf. However, this method may be used
 * by the client app itself to send push notifications either to other clients, or to itself which
 * can be used to test connectivity.
 *
 * The implementation relies on backend code generated by CLI which forwards the body JSON to the
 * server-side implementation of this method.
 *
 * @param message to deliver.
 * @returns promise of async execution resolving to UUIDs of jobs in asynchronous delivery,
 *    empty when no apps or devices got selected by the message criteria or null when no
 * 		target apps or devices exist at all.
 */
function postPushNotification(message) {
    return web.post(pushUrl, message);
}
exports.postPushNotification = postPushNotification;
/**
 * creates a device filter for the user attribute of push devices matching any of a given set of
 * users.
 *
 * @param users* to filter on.
 * @returns device filter matching devices of given users.
 */
function pushDeviceFilterByUsers() {
    var users = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        users[_i - 0] = arguments[_i];
    }
    if (users.length <= 0) {
        return {
            type: 'null',
            fieldName: 'user',
            isNull: true
        };
    }
    else if (users.length === 1) {
        return {
            type: 'string',
            fieldName: 'user',
            value: domain.uuidOf(users[0])
        };
    }
    else {
        var uuids = users.map(function (user) { return domain.uuidOf(user); });
        return {
            type: 'stringEnum',
            fieldName: 'user',
            values: uuids
        };
    }
}
exports.pushDeviceFilterByUsers = pushDeviceFilterByUsers;
/**
 * gets push notification status.
 *
 * The implementation relies on backend code generated by CLI which uses the server-side
 * PushService to query for Job by uuid.
 *
 * @param uuidOrMessage to query.
 * @returns promise of async execution resolving to push Job information.
 */
function fetchPushNotification(uuidOrMessage) {
    var uuid = _.isString(uuidOrMessage) ? uuidOrMessage : uuidOrMessage.uuid;
    return web.get(pushUrl + '/' + uuid);
}
exports.fetchPushNotification = fetchPushNotification;
//# sourceMappingURL=push.js.map